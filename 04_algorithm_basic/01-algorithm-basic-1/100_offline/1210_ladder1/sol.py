import sys
sys.stdin = open('input.txt')

'''
    내 위치 data[row][col] 기준, 상하좌우는 어떻게 알 수 있는가?
    값 X를 기준으로, 상하좌우의 값이 궁금하다.
    0 1 2
  0 A B C                data[0][1] = B
  1 D X E  data[1][0]= D data[1][1] = X   data[1][2] = E
  2 F G H                data[2][1] = G
'''
# #    상 하 좌 우
# dx = [0, 0, -1, 1]  # col 인덱스의 값이 어떻게 처리 될 것이냐
# dy = [-1, 1, 0, 0]  # row 인덱스의 값이 어떻게 처리 될 것이냐
#    좌 우 하  # 사다리는 좌우 먼저 조사하고 다음 오른쪽
dx = [-1, 1, 0]
dy = [0, 0, 1]

def search(col):
    # 후보군이 바뀌어서 함수가 재 호출 될 떄마다
    # 그 후보군만을 위한 방문 표시여부
    # 방문 여부 표시용 2차원 리스트 만들기
    # 0이 100개 차있는 리스트를 100번 반복해서 만든다.
    visited = [[0] * 100 for _ in range(100)]
    '''
        시작지점은 항상 data[0][col] 부분에서 출발
        col: 후보군 중 하나였던, 지점의 좌표
        도착지점에 도착했으면 True 아니면 False 반환
        return: True or False를 반환
    '''
    row = 0
    # 첫 시작지점 방문 표시
    visited[row][col] = 1
    # 언제까지? row의 값이 99가 될 때 까지
    # data[99][col]
    while row != 99:
        # 3방향에 대해서 조사
        for k in range(3):
            # col + (-1)   -> 현재 위치의 왼쪽 좌표
            next_col = col + dx[k]     # 다음 조사 지점의 col 인덱스
            next_row = row + dy[k]     # 다음 조사 지점의 row 인덱스
            # 아래로 내려가기 위해서는 전재조건이 필요하다.
            # 좌우가 이동 가능한지 확인하고
            # 이전에 방문한적이 있었는지 없었는지 확인 해야함.
            # print(next_row, next_col)
            if 0 <= next_col < 100 and 0 <= next_row < 100:
                if data[next_row][next_col] != 0:
                    if data[next_row][next_col] == 2:
                        return True
                    if visited[next_row][next_col] == 0:
                        # 한칸 이동 -> next_row,col에서 이미 다음칸
                        # 그럼, 원래 현재 위치를 담고 있었던 값은?
                        row, col = next_row, next_col
                        # 다음위치 방문 처리
                        visited[row][col] = 1
    return False


# 총 10개의 테스트 케이스가 주어진다.
for _ in range(10):
    # 첫 번째 줄에는 테스트 케이스의 번호가 주어지며,
    test_case = input()
    # 바로 다음 줄에 테스트 케이스가 주어진다.
    # 100 x 100 크기의 2차원 배열
        # 받을 때, 나는 이 값을 정수로 바꿀 필요가 있을까?
    # 입력 받은 문자열을 공백으로 쪼개서, 각 요소를 정수로 바꾸고
    # 그 값을 리스트로 만들건데, 이걸 100번 반복한다.
    data = [list(map(int, input().split())) for _ in range(100)]
    # for idx in range(100):
    #     print(data[idx])
    # 0: 평면, 1: 길, 2: 도착 지점
    # 첫번째 행에 있는 값이 1인 경우들이 모두 출발 후보군
        # 그 말은, 나는 그 후보군들에서 모두 사다리 조사 해야할 듯
    # 그냥 조사하고 끝낼거냐? 아니면 후보군 이라는 리스트에 담을거냐?
    candidated = []         # 후보군을 모을 리스트
    first_row = data[0]     # 후보군이 존재할 수 있는 첫번째 행
    # 그 첫번째 행을 순회하면서, 값이 1인 경우를 모두 후보군에 삽입
    # for value in first_row:   # 1 or 0
        # if value == 1:      # 해당 값이 1 이라면
    #     if value:             # 해당 값이 True라면...
    #         candidated.append(value)
    # print(candidated)         # 어... 전부 1이 들어갔네...
    # 이제부터는... index로 접근하는 연습하기
    for idx in range(len(first_row)):   # 첫번째 행의 0 ~ 99까지 순회
        if first_row[idx]:              # 그 idx 번째 값이 True 라면
            candidated.append(idx)      # 그 idx 자체를 후보군에 삽입
    # 이 후보군을 순회하여서..
    # 사다리를 타는 함수를 호출할때,
    # 시작 지점으로 값들을 넘겨준다
    print(candidated)
    '''
        사다리를 타는 행위를 코드로 구현한다?
        작게 손으로 그려보자
    data[0][0], data[0][4] 에서 출발,
     y   0 1 2 3 4 5 6 7 8  -> x    
     0   1 0 0 0 1 0 0 0 1   # 이곳의 1이라고 하는 모든 곳에서 출발
     1   1 0 0 0 1 0 0 0 1   # 사다리 규칙은, 일단 아래로 내려가
     2   1 1 1 1 1 0 0 0 1   # 아래로 내려간다? y값이 1 증가한다.
     3   1 0 0 0 1 1 1 1 1   # 언제까지? 여기선 5, 문제에선 99
     4   1 0 0 0 1 0 0 0 1   # 무조건 내려가는게 아니라 좌우 확인
     5   1 0 0 0 2 0 0 0 1   # 좌우에 1이 있다면 그곳으로 이동
        # 좌우가 갈수 있다고 무조건 가는게 아니라
        # 한번 지나왔던 길을 다시 돌아가선 안된다.
            # 해결방안
                # 1. 다음 위치의 값이 0이면 못가네?
                # 1-1. 지나왔던 길을 못 돌아가게 만들어 버리기
                # 1-2. data[row][col] = 0 (0으로 바꿔치기) 
                    # 엇? 원본을 훼손했더니 다음 후보군이
                    # 원래와 같은 조건으로 작업을 할 수가 없다.
                # 1-3. 원본을 어딘가에 복사해두고 쓰자.
                
                # 2. 이번 회차에 방문했었던 곳을 기록 하자.
                # 2-1. 내가 이동해야 하는 전체 데이터 크기와 동일한
                #       방문 여부 확인용 2차원 리스트를 만들어서 작업
        0 0 0 0 0 0 0 0 0
        0 0 0 0 0 0 0 0 0
        0 0 0 0 0 0 0 0 0
        0 0 0 0 0 0 0 0 0
        0 0 0 0 0 0 0 0 0
        0 0 0 0 0 0 0 0 0   
    '''

    for item in candidated: # 후보군을 순회한다.
        # 그 각각의 후보군 item으로 조사를 진행한다.
        # 그건 함수로 따로 빼보자.
        # 함수를 호출한 결과가 True면 거기서 조사 정료
            # 왜냐면, True인겨우 도착지점에 도달했다는 뜻
        if search(item):
            break

    # 지정된 도착점에 대응되는 출발점 X를 반환하는 코드
    # 최종 출력 예시 #1 67
    print(f'#{test_case} {item}')