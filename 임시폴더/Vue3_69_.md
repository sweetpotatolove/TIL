## ※주의※ 정적 & 동적 props  
- 첫 번째는 정적 props로 문자열 `"1"`을 전달  
- 두 번째는 동적 props로 숫자 `1`을 전달
```
<!-- 1 -->
<SomeComponent num-props="1" />
<!-- 2 -->
<SomeComponent :num-props="1" />
```

## Props 선언 시 “객체 선언 문법”을 권장하는 이유  
- 컴포넌트를 가독성이 좋게 문서화하는 데 도움이 됨  
- 다른 개발자가 잘못된 유형을 전달할 때 브라우저 콘솔에 경고를 출력하도록 함  
- 추가로 props에 대한 유효성 검사로 활용 가능
```python
defineProps({
  // 여러 타입 허용
  propB: [String, Number],
  // 문자열 필수
  propC: {
    type: String,
    required: true
  },
  // 기본 값을 가지는 숫자형
  propD: {
    type: Number,
    default: 10
  },
})
```

## emit 이벤트도 “객체 선언 문법”으로 작성 가능  
- emit 이벤트 또한 객체 구문으로 선언된 경우 유효성을 검사할 수 있음
```python
const emit = defineEmits({
  // 유효성 검사 없음
  click: null,
  // submit 이벤트 유효성 검사
  submit: ({ email, password }) => {
    if (email && password) {
      return true
    } else {
      console.warn('submit 이벤트가 옳지 않음')
      return false
    }
  }
})
const submitForm = function (email, password) {
  emit('submit', { email, password })
}
```

# Computed Properties

# Computed

## computed()  
- "계산된 속성"을 정의하는 함수  
- 미리 계산된 속성을 사용하여 템플릿에서 표현식을 단순하게 하고 불필요한 반복 연산을 줄임

## computed 기본 예시 (1/2)  
- 할 일이 남았는지 여부에 따라 다른 메시지를 출력하기 
```
<!-- Computed.vue-->
const todos = ref([
  { text: 'Vue 실습' },
  { text: '자격증 공부' },
  { text: 'TIL 작성'}
])
```
- 템플릿이 복잡해지며 `todos`에 따라 계산을 수행하게 됨  
- 만약 이 계산을 템플릿에 여러 번 사용하는 경우에는 반복이 발생

## computed 기본 예시 (2/2)  
- computed 적용  
  - 반응형 데이터를 포함하는 복잡한 로직의 경우 `computed`를 활용하여 미리 값을 계산하고 계산된 값을 사용
```python
import { ref, computed } from 'vue'

const restOfTodos = computed(() => {
  return todos.value.length > 0 ? '아직 남았다' : '퇴근!'
})
```
```
<h2>남은 할 일</h2>
<p>{{ restOfTodos }}</p>
```

## computed 특징  
- 반환되는 값은 computed ref이며, 일반 ref와 유사하게 계산된 결과를 `.value`로 참조할 수 있음  
  (템플릿에서는 `.value` 생략 가능)  
- computed 속성은 의존된 반응형 데이터를 자동으로 추적  
- 의존하는 데이터가 변경될 때만 재평가  
- `restOfTodos`의 계산은 `todos`에 의존하고 있으며,  
  따라서 `todos`가 변경될 때만 `restOfTodos`가 업데이트됨
```python
const restOfTodos = computed(() => {
  return todos.value.length > 0 ? '아직 남았다' : '퇴근!'
})
```

# Computed vs. Methods

## computed와 동일한 로직을 처리할 수 있는 method  
- computed 속성 대신 method로도 동일한 기능을 정의할 수 있음  

```vue
<!-- Computed.vue -->
const getRestOfTodos = function () {
  return todos.value.length > 0 ? '아직 남았다' : '퇴근!'
}
```
```
<p>{{ getRestOfTodos() }}</p>
```

## computed와 method 차이  
- computed 속성은 의존된 반응형 데이터를 기반으로 캐시(cached) 됨  
- 의존하는 데이터가 변경된 경우에만 재평가됨  
- 즉, 의존된 반응형 데이터가 변경되지 않는 한 이미 계산된 결과에 대한 여러 참조는 다시 평가할 필요 없이 이전에 계산된 결과를 즉시 반환  
> 반면, method 호출은 다시 렌더링이 발생할 때마다 항상 함수를 실행

## Cache (캐시)  
- 데이터나 결과를 일시적으로 저장해두는 임시 저장소  
- 이후 같은 데이터나 결과를 다시 계산하지 않고 빠르게 접근할 수 있도록 함

## computed와 method의 적절한 사용처  
- computed  
  - 의존하는 데이터에 따라 결과가 바뀌는 계산된 속성을 만들 때 유용  
  - 동일한 의존성을 가진 여러 곳에서 사용할 때 계산 결과를 캐싱하여 중복 계산 방지  

- method  
  - 단순히 특정 동작을 수행하는 함수를 정의할 때 사용  
  - 데이터 의존 여부와 관계없이 항상 동일한 결과를 반환하는 함수

## method와 computed 정리  
- computed  
  - 의존된 데이터가 변경되면 자동으로 업데이트  
- method  
  - 호출해야만 실행됨  
> 무조건 computed만 사용하는 것이 아니라, 사용 목적과 상황에 맞게 computed와 method를 적절히 조합하여 사용

# Watchers

# watch

## watch()  
- 하나 이상의 반응형 데이터를 감시하고, 감시하는 데이터가 변경되면 콜백 함수를 호출

## watch 구조  
```py
watch(source, (newValue, oldValue) => {
  // do something
})
```
- 첫 번째 인자 (source)  
  - watch가 감시하는 대상 (반응형 변수, 값을 반환하는 함수 등)

- 두 번째 인자 (callback function)  
  - source가 변경될 때 호출되는 콜백 함수  
  1. newValue
    - 감시하는 대상이 변화된 값  
  2. oldValue (optional)
    - 감시하는 대상의 기존 값

## watch 기본 동작  
```vue
<!-- Watcher.vue -->

<button @click="count++">Add 1</button>
<p>Count: {{ count }}</p>
```

```js
const count = ref(0)

watch(count, (newValue, oldValue) => {
  console.log(`newValue: ${newValue}, oldValue: ${oldValue}`)
})
```

출력 예시  
```
newValue: 1, oldValue: 0  
newValue: 2, oldValue: 1  
newValue: 3, oldValue: 2
```

## watch 예시 (1/2)  
- 감시하는 변수에 변화가 생겼을 때 연관 데이터 업데이트하기  

```vue
<input v-model="message">
<p>Message Length: {{ messageLength }}</p>
```

```js
const message = ref('')
const messageLength = ref(0)

watch(message, (newValue) => {
  messageLength.value = newValue.length
})
```

## watch 예시 (2/2)  
- 감시하는 변수에 변화가 생겼을 때 연관 데이터 업데이트하기  

```text
hello!
Message length: 6
```

## 여러 source를 감시하는 watch  
- 배열을 활용  

```js
watch([foo, bar], ([newFoo, newBar], [prevFoo, prevBar]) => {
  /* ... */
})
```

# computed vs. watch

## Computed와 Watchers

| 구분 | Computed | Watchers |
|------|-----------|-----------|
| 공통점 | 데이터의 변화를 감지하고 처리 | 데이터의 변화를 감지하고 처리 |
| 동작 | 의존하는 데이터 속성의 계산된 값을 반환 | 특정 데이터 속성의 변화를 감시하고 작업을 수행 *(side-effects)* |
| 사용 목적 | 계산된 값을 캐싱하여 재사용, 중복 계산 방지 | 데이터 변화에 따른 특정 작업 수행 |
| 사용 예시 | 연산된 길이, 필터링된 목록 계산 등 | DOM 변경, 비동기 작업 수행, 외부 API 연동 등 |

> computed와 watch 모두 의존(감시)하는 원본 데이터를 직접 변경하지 않음

# computed 주의사항

## ※주의※ computed의 반환 값은 변경하지 말 것  
- computed의 반환 값은 의존하는 데이터의 파생된 값  
  - 이미 의존하는 데이터에 의해 계산이 완료된 값  
- 일종의 snapshot이며, 의존하는 데이터가 변경될 때만 새 snapshot이 생성됨  
- 계산된 값은 읽기 전용(read-only) 으로 취급되어야 하며 변경되어서는 안 됨  
- 대신 새 값을 얻기 위해서는 의존하는 데이터를 업데이트해야 함

## ※주의※ computed 사용 시 원본 배열 변경하지 말 것  
- computed에서 `reverse()` 및 `sort()` 사용 시 원본 배열을 변경하기 때문에 원본 배열의 복사본을 만들어서 진행해야 함  

```js
// ❌ 잘못된 예시
return numbers.reverse()

// ✅ 올바른 예시
return [...numbers].reverse()
```

# 추가 주제

## Lifecycle Hooks
- Vue 인스턴스 생애주기 동안 특정 시점에 실행되는 함수

## Lifecycle Hooks Diagram
- 인스턴스의 생애 주기 중간 중간에 함수를 제공하여 개발자가 특정 단계에서 원하는 로직을 작성할 수 있도록 함

## Lifecycle Hooks 예시 (1/3)  
1. Vue 컴포넌트 인스턴스가 초기 렌더링 및 DOM 요소 생성이 완료된 후 특정 로직을 수행하기  

```vue
<!-- LifecycleHooks.vue -->

import { ref, onMounted } from 'vue'

onMounted(() => {
  console.log('mounted')
})
```

```
  mounted
  >
```

## Lifecycle Hooks 예시 (2/3)  
2. 반응형 데이터의 변경으로 인해 컴포넌트의 DOM이 업데이트된 후 특정 로직을 수행하기  

```vue
<button @click="count++">Add 1</button>
<p>Count: {{ count }}</p>
<p>{{ message }}</p>
```
```
import { ref, onUpdated } from 'vue'
```
```
const count = ref(0)
const message = ref(null)

onUpdated(() => {
  message.value = 'updated!'
})
```

```
Add 1

Count: 1

updated!
```

## Lifecycle Hooks 특징  
- Vue는 Lifecycle Hooks에 등록된 콜백 함수들을 인스턴스와 자동으로 연결함  
- 이렇게 동작하려면 hooks 함수들은 반드시 동기적으로 작성되어야 함  
- 인스턴스 생애 주기의 여러 단계에서 호출되는 다양한 hooks가 존재하며, 가장 일반적으로 사용되는 것은 `onMounted`, `onUpdated`, `onUnmounted`  
- [Vue Lifecycle Hooks 공식 문서](https://vuejs.org/api/composition-api-lifecycle.html)

# Virtual DOM

## Virtual DOM  
- 가상의 DOM(Virtual DOM) 을 메모리에 저장하고 실제 DOM과 동기화하는 프로그래밍 개념  
- 실제 DOM과의 변경 사항을 비교하여 변경된 부분만 실제 DOM에 적용하는 방식  
- 웹 애플리케이션의 성능을 향상시키기 위한 Vue의 내부 렌더링 기술

```html
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
  ---
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
```
- Vue의 영역
- (Virtual DOM)

## 내부 렌더링 과정

## Virtual DOM 패턴의 장점  
- 효율성  
  - 실제 DOM 조작을 최소화하고, 변경된 부분만 업데이트하여 성능을 향상  

- 반응성  
  - 데이터의 변경을 감지하고 Virtual DOM을 효율적으로 갱신하여 UI를 자동으로 업데이트  

- 추상화  
  - 개발자는 실제 DOM 조작을 Vue에게 맡기고, 컴포넌트와 템플릿을 활용하는 추상화된 프로그래밍 방식으로 원하는 UI 구조를 구성하고 관리할 수 있음

## Virtual DOM 주의사항  
- 실제 DOM에 직접 접근하지 말 것  
  - JavaScript에서 사용하는 DOM 접근 관련 메서드 사용 금지  
  - querySelector, createElement, addEventListener 등  
> Vue의 ref()와 Lifecycle Hooks 함수를 사용해 간접적으로 접근하여 조작할 것

## 직접 DOM 엘리먼트에 접근해야 하는 경우  
- `ref` 속성을 사용하여 특정 DOM 엘리먼트에 직접적인 참조를 얻을 수 있음  

```vue
<template>
  <input ref="input" />
</template>

<script setup>
import { ref, onMounted } from 'vue'

// 변수명은 템플릿 ref 값과 일치해야 함
const input = ref(null)

onMounted(() => {
  console.log(input.value) // <input>
})
</script>
```
