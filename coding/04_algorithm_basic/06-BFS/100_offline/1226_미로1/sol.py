# 이쯤... 되면... 알고리즘은... 거의 외운 reference code 기반으로 작성만 잘 하면 되는거고
# 내가 해야하는건 이제부터는 수능 언어(국어)영역이다.
# 사실상 국어 시험이다.
'''
16*16 행렬의 형태로 만들어진 미로에서         -> 2차원 배열
흰색 바탕은 길, 노란색 바탕은 벽을 나타낸다.  -> 조건 이겠구나

가장 좌상단에 있는 칸을 (0, 0)의 기준으로 하여, -> 아, index 그대로 써도 되겠구나
가로방향을 x 방향, 세로방향을 y 방향이라고 할 때,  -> 가로방향 x, 세로방향 y는... 내가 편한대로 변수 바꿔서 쓰자.
미로의 시작점은 (1, 1)이고 도착점은 (13, 13)이다.  -> 출발점, 도착점이 정해져 있는 것 같다.

주어진 미로의 출발점으로부터 도착지점까지 갈 수 있는 "길이 있는지 판단" <- 여기가 제일 중요하구나.
'''

# 문제에서의 요구사항들이 잔뜩 있는데, 왜 "길이 있는지 판단" 하는 부분이 가장 중요하다라고 하였는가?
# 1. 위에 있는 각종 조건들은, 데이터를 내려받거나, 처리하는 과정에서 코드 몇줄로 한단 하고 끝
# 2. 가장 중요한 우리의 logic을 무엇으로 할것인가를 판단하는데는 결국 최종 목적이 제일 중요하다.
    # 그래서 했던 질문, 왜 BFS로 풀었느냐?
    # 그럼 누군가는 물을겁니다.
        # 어, DFS가 더 빠른가요? -> 지금 하자는 이야기는 그게 아니죠?
# 완전탐색이 가능한 탐색 방식을 찾아야 한다.
    # 여러가지 방법이 있을 것이다.
    # 현재의 이 2차원 행렬의 생김새와 각 지점간의 관계를 생각 했을 때,
        # 이 문제는 어떤 문제냐? 그래프에서 특정 정점 (1, 1) 이 도착 정점 (13, 13)과 간선으로 이어져 있느냐.
            # 이걸 묻는 문제이다.
        # 그럼, 우리는 이 문제가 그래프를 탐색할 수 있는 완전 탐색 방식인
        # DFS와 BFS중 어떤 것을 선택할 것이냐? 를 생각해야 할 것이고
        # 만약, 그 중에 DFS를 선택했다면?
# DFS를 할 수 있는 방법을 생각해 봐야 한다.
    # DFS란? 무엇인가?
        # 내 정점 X에서 인접해 있는 모든 정점들을 다음 탐색 후보군에 넣고,
        # 그 후보군들을 LIFO 원칙에 따라서, 다시
        # 다음 후보군 정점 Y에서 인접한 모든 정점들을 탐색한다.
    # 따라서, 우리는 시작정점 (1, 1) 기준으로 인접 정점들이 누구인지 알아야 하는데...
        # 어? 간선 정보가 주어지지 않는다.
        # 주어지는 정보는 오로지, (1, 1) 이 0이라는 점과,
        # 그리고, (1, 2) 역시 0일때, 우리는 (1, 1) 이 (1, 2) 지점과 이어져 있다. 라고 볼 수 있다.
            # 그럼 이정보를 우리가... 인접 리스트 (그래프를 표현 하는 방식)으로 그리자면?
            # adj_list = {
            #   (1, 1): [(1, 2)],
            #   (1, 2): [(1, 3)],
            # ...
            # }
        # 근데 이렇게, 모든 정점들에 대해서... 인접 리스트를 만들자니.,.. 16*16은 충분히 크다.
        # 그리고... matrix상에 1로 표기되어 있는 소위 말해 "벽" 이라고 하는 각 정점들은,
        # 정점은 존재하고, 그 정점들 사이의 연결 관계도 존재하지만, 내 인접 리스트에는 영향을 전혀 안 미친다.

    # 내가 탐색해야 할 정점을 기준으로, 인접해 있는 정점이라는 사실을 문제에서 몇가지 조건으로 내주었다.
        # 1. 상하좌우 (즉, 좌표값 x, y에 대해서 각각 (-1, 0), (1, 0) ... 등을 더한 위치이다.
        # 2. 그 상하좌우 좌표에 존재하는 정점의 값이 1이 아니어야 한다.
        # 3. 목표로 하고 있는 정점 (13, 13) 이라는 곳은 3으로 표기되어있다.
# 일단 데이터를 입력받아

import sys
sys.stdin = open('input.txt')

'''
[입력]
총 10개의 테스트케이스가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 테스트 케이스의 번호가 주어지며, 바로 다음 줄에 테스트 케이스가 주어진다.
16*16 행렬
1은 벽
0은 길, 
2는 출발점,
3은 도착점

[출력]
(1 - 가능함, 0 - 가능하지 않음).
#1 1
#2 0
'''
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
def escape(x, y):
    '''
    # 그 x, y 기준으로 상하좌우 인접한 경로를 이동해야하고...
    # 이동한번 하고 나면 두번다시 돌아올 일 없고
    # 이동 하려면, 내 상하좌우에 인접한 값이 1이 아니어야하고
        # 0은 길이고, 3은 도착점이니까....
        # 둘다 갈 수 있어야 하니까.... 물론... or로 처리도 가능하긴할듯?
    '''
    # 조사 지점을, 리스트로 묶어서, x, y를 한 세트로 묶어서 담는다.
    start_point = [(x, y)]
    # 그리고, 그 start_point 라는 리스트가 빌 때까지 조사한다.
    while start_point:
        # 반복문에서 결국 제일 중요한건....
        # 반복 하는 동안에,,, 동일한 조건을,, 동일한 변수에 담아야
        # 동일하게 동작 하겠죠?
        x, y = start_point.pop()
        # 4방향 조사
        for k in range(4):
            nx = x + dx[k]
            ny = y + dy[k]

            # 만약 그 다음 위치가 '1'이 아니면 (벽이 아니면)
            if data[nx][ny] != 1:
                # 뭔가를 할거임
                # 도착 지점이라면?
                if data[nx][ny] == 3:
                    return 1    # 찾았다.
                # 도착 지점이 아니면?
                # 도착 지점은....아니긴 한데 갈 수는 있는거 같고...
                # 그러면 이동한다 -> 즉, 이전에 내가 왔던길을 없애야한다.
                # TypeError: 'str' object does not support item assignment
                # ??? 뭔소리지? data[x][y] -> 뭔데? 아... 문자열
                # 문자열은 변형 불가능이지....?
                data[x][y] = 1
                # 내가 갈 수 있는 다음 행선지 nx, ny를 찾았는데
                # 그 좌표에 대해서도 내가 지금 x, y로 했던일을 똑같이 반복하고 싶어.
                # 언제까지? -> 그 nx, ny 라고 하는 지점이 없을때까지!
                # 음... 그걸 어떻게 해야하지?
                # x, y 를 기준으로 4방향에 대해서 조사를 하다보면...
                # 아마... 갈 수 잇는 nx, ny 들이 여러개가 나올 것이다..
                    # 그리고 걔네들은 한 세트로 묶여서 봐야한다...
                    # 여러개의 값들을 한 세트로 묶어서 담은 다음에...
                    # 그 담겨 있는 통이 빌 때까지 반복?
                    # 리스트에담자. 그리고, 그 리스트가 있는동안 반복하자.
                    # 코드 맨위로...올라가자..
                start_point.append((nx, ny))
    return 0

for _ in range(10):
    test_case = int(input())
    data = []
    for _ in range(16):     # 16줄에 대해서
        # data.append(input().split())
        # 사실 알고보니 나는 이값들을 바꿔 줄 필요가 있었다.
        # 그때와서 정수로 바꾸거나...
        # 아니면.. 방문 여부 체크용 리스트를 만들어서.... 체크
            # 근데 그렇게 코드를 잔뜩 바꿔야 하는 경우가 생기면
            # 추천하는 바는????
                # 새파일 만드세요 ^^
            # 가끔이제 그런 이야기를 해용... 제가 낳은 제 새끼 같은 코드를 어떻게 버립니까..
                # ㄴㄴ 그거 본인이 낳은거아님;;; 어디서 줏어온 코드임;;;
                # 난 그렇게 가르친적 없음;;;
                # ㄴㄴㄴ 그거 뻐꾸기 새끼임;;
        data.append(list(map(int, input())))
    # print(data) # 잘 입력 받았는지 확인을 해보니... 값이 공백없이 주어져서 split()하면 이상하다.

    '''
        1. 입력받은 데이터가 분명히, 0, 1, 2, 3 인데...
        2. 지금 입력받은 결과 data를 출력 해보니, 문자열이네..?
        3. 수업시간에 맨날 정수로 바꿨었는데.....
        4. 정수로 바꿔야할까? -> 굳이?    (연산을 할 일이 없는걸?)
        5. 우리가 판별해야 하는 정보는 '0'이냐 '1'이냐 '2'냐 '3'이냐 밖에없다...
        ---
        1. 위에 있는 저런 것들에 신경쓸 시간에...
        2. 시작 정점과 도착 정점의 index가 정말 (1, 1) (13, 13) 인지를 확인하자.
        3. 따라서, 습관적으로 적어도 되는 코드는 print 문 밖에 없음
            단, 적어서 출력해서 확인했으면 주석처리
        4. 출력 결과를 확인해 봤더니... 주어진 TC들에서 시작 정점은 (1, 1) 이더라.
        5. 근데, 도착 정점은 (13, 13)이 아닌 경우도 있고, 문제에서도 예시에서 다른게 있더라!
        6. 이때, 우리가 생각해야 할 것은.... 시작 정점이 (1, 1) 이라는 확답이 없었고,
            6-1. 시작 정점에 있는 값이 2라는 사실만이 주어졌다!
    '''
    # 시작 정점 위치 찾기 -> 거기서 부터 탐색해 나갈 것이니까.
    # 아... result를 내가 시작정점에서 출발했을때만 초기화 해놨구나...
    result = False  # 기본적으로는 도착 못했다고 가정해놓고 작업하자.
    for x in range(16):
        for y in range(16):
            if data[x][y] == 2:       # 시작 정점이라면
                '''
                # print(x, y, data[x][y]) # 출력 결과 2들 잘 찾았다...
                # 시작 정점 찾았으니, 이곳에서부터 도착 정점을 찾으러가는 코드를 작성
                # 이 아래에서 바로 코드 적으면 안되나? 안될 이유는 없다.
                # 다만, 헷갈린다. -> 함수화 할건데..
                # stack = [(x, y)]
                # while stack: ....
                # 어
                '''
                # 만약, 어떤 함수를 실행이 끝나서, 도착이든 실패든 끝났다!
                result = escape(x, y)
                break   # 그럼 이제 그만!
                # 그러나, 이 break는 y에 대한 for만 break
                # 만약, x에 대한 break도 하고 싶으면...
                # 함수 실행한 결과로 반환 받은 값을 result라는 곳에 담고
        if result:  # 그 값이 True라면
            break   # whdfy
    # 모든 작업이 모두 끝나고 난 뒤
    # 결과가 내가 생각한거랑 다르게 이상함.. None도 나오고 막 그럼...
    # 아마 0이어야 할 것 같은데...
    print(f'#{test_case} {result}')







