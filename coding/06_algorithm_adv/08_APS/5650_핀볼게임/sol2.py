import sys
sys.stdin = open('input.txt')

# 상하좌우
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

''' 1. 규칙 구상.
    블록 구성, 규칙을 작성한다. 웜홀은 별도로 동작하므로 따로 처리한다.
    상하좌우 이동중에 마주한 경우에 대해 처리할 것.
    복잡하게 생각하지 말고, 상하좌우 진행 도중 마주했을때에 적절히 처리하자.
    상하좌우는 결국 k가 0, 1, 2, 3인 경우에 대해서 처리하면 된다. 
'''
block = [
    [],  # 0은 사용하지 않음
    # 1: 상 -> 하 / 하 -> 우 / 좌 -> 상 / 우 -> 좌
    [1, 3, 0, 2],
    # 2: 상: 우 / 하: 상 / 좌: 하 / 우: 좌
    [3, 0, 1, 2],
    # 3: 상: 좌 / 하: 상 / 좌: 우/ 우: 하
    [2, 0, 3, 1],
    # 4: 상: 하 / 하: 좌 / 좌: 우 / 우: 상
    [1, 2, 3, 0],
    # 단, 범위를 벗어나는 경우도 5와 동일한 규칙 작용
    # 5: 상: 하 / 하: 상 / 좌: 우 / 우: 좌
    [1, 0, 3, 2],
]

def search(x, y, dir):   # 9-1. 방향 정보 인자 추가
    global result
    ''' 8. 조사 전 점검.
        잠깐... DFS 탑색이 필요한게 맞아?
        stack이나 queue가 진짜 필요한가? 아니다.
        후보군은 존재하지 않음. 나는 현재 지정된 방향으로 나가기만 하면된다.
        즉, 후보군이래봤자 현재 방향으로 나아가는중인 공 하나 밖에 없다.
        그렇다면, 재귀형식으로 나아가기만 하면된다. 현재 방향을 향해서
        
        99. 그러나 이 경우, 최대 재귀 스택 오류가 발생한다.
            - while 문이어도 되지 않나? 앞으로만 나갈건데?
    '''
    # 시작 지점 초기화
    nx, ny = x, y
    score = 0
    while True:
        # 11. 이번 방향 dir 위치에 대한 조사를 위해 nx, ny 정의
        nx, ny = nx + dx[dir], ny + dy[dir]

        '''
            12-1. 범위를 벗어난다면?
            12-2. 범위를 벗어나지 않는것만 쓰다보니... 헷갈리네 
                - 범위를 벗어나지 않는 상황이 아닌 경우: not
            12-3. 이떄는 block의 5번으로 처리할 것.
        '''
        if not (0 <= nx < N and 0 <= ny < N):
            '''
                13. 벽을 만나거나, 5번 블록을 만나면 block 5번에 지정된
                    현재 방향에서 어디로 튕겨야 할건지 활용
            '''
            dir = block[5][dir]
            # search(nx, ny, next_dir, acc+1) # 다음 방향으로 조사 출발
            score = score+1

        # 14. 그 외 1~5 블록들에 대해서
        elif 1 <= data[nx][ny] <= 5:
            dir = block[data[nx][ny]][dir]
            # search(nx, ny, next_dir, acc + 1)  # 다음 방향으로 조사 출발
            score = score+1
        # 15-1. 웜홀이면?
        elif 6 <= data[nx][ny]:
            '''
                15-2. 웜홀은 무조건 쌍으로 나오므로, 만난경우 무조건 있다.
                15-3. 현재 웜홀이 몇번 웜홀이며, 그때, 어디에 담겨있는지 찾자.
                15-4. 동일 번호 웜홀에 속하지만, 나랑 좌표가 다르면 다른 웜홀
                15-5. 그럼 그 좌표로 이동해서, 동일한 방향으로, 누적값 추가 없이 조사 
            '''
            for wx, wy in wormhole[data[nx][ny]]:
                if (nx, ny) != (wx, wy):
                    nx, ny = wx, wy
                    # search(wx, wy, dir, acc)
                    break
            '''
                16-1. 블랙홀이거나 시작좌표면 종료되어야 한다.
                16-2. 블랙홀인 경우? data[nx][ny] == -1
                16-3. 어라...? 시작좌표는...? 이번회차 좌표는?
                    - 이 함수가 실행되기 전 x, y
                16-4. 두가지 조건을 별도로 관리해야 하는데 우선순위를 모르겠네? 괄호
            '''
        elif (nx, ny) == (x, y) or data[nx][ny] == -1:
            # 최댓값 갱신
            return score

T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    # -1 < k < 10
    data = [list(map(int, input().split())) for _ in range(N)]

    ''' 2. 두번째 규칙 구상.
    핀볼이 웜홀에 빠지면 동일한 숫자를 가진 다른 반대편 웜홀로 빠져 나오게 되며
    진행방향은 그대로 유지된다.
    1. 6이상에 대해서는 별도로 처리 해야한다. (10 이상의 숫자 주어지지 않음)
    2. 웜홀의 각 좌표를 기록 해 둘 필요 있음
    단, 웜홀 정보는 매 TC마다 달라지므로, 정의는 데이터를 입력 받고 진행
    '''
    # 2-1. 웜홀 초기 모양 초기화
    wormhole = {
        6: [], 7: [], 8: [], 9: [], 10: []
    }
    ''' 3. 게임의 룰 정의
        게임은 핀볼이 출발 위치로 돌아오거나, 블랙홀에 빠질 때 끝나게 되며
        시작 지점 둘 필요있음. (블랙홀은 -1로 나타나고, 그대로 종료할 것이므로 상관없음)
            단, 시작지점은 내가 찾아내야 하는것
            단, 블록, 웜홀 또는 블랙홀이 있는 위치에서는 출발할 수 없다.  
                - 0인 지점에서 출발 할 것  
        점수는 벽이나 블록에 부딪힌 횟수가 된다.
            모든 위치에서 모든 방향으로 출발 하도록 시도 해 보아야한다.
            게임에서 얻을 수 있는 점수의 최댓값을 구하여라!
            초기 result는 최솟값 0으로 초기화
        단, result는 최종 결괏값이고, 각 회차마다 점수는 별도로 기록하여야 함.        
    '''
    result = 0
    # 4. 우선 모든 정점에 대해서 웜홀 정보 초기화
    for x in range(N):
        for y in range(N):
            if data[x][y] >= 6: # 6이상이면 웜홀 10 이상은 없음
                wormhole[data[x][y]].append((x, y)) # 해당 좌표 삽입
    # 5. 웜홀 정보 출력 (심지어, 웜홀은 없을 수도 있음)
    # print(wormhole)

    # 6. 모든 정점에서 출발
    for x in range(N):
        for y in range(N):
            if data[x][y] == 0:     # 단, 0인 지점에서
                # 10. 이번 좌표에서 4방향에 대해 출발 시킬것
                for k in range(4):
                    '''
                        7. 일단은 별다른 조건 없이 좌표만 가지고 시작
                        9-2. 방향 정보 인자 추가. 우선은 0 위로 조사보내자.
                        9-3. 잠깐, 우선 상으로 출발을 보내면 그 이후 방향은?
                            - 위의 각종 룰들에 의해 결정되는 것이다.
                            - 그럼 출발 방향은? 이번 좌표에 대해서 4번? 반복문 추가
                    '''
                    result = max(result, search(x, y, k))
    print(f'#{tc} {result}')

