import sys
sys.stdin = open('input.txt')

# 전선 연결 상하좌우
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def search(r, acc_core, acc_line):
    ''' 3. 조사 방식 정리
        모든 후보군에 대해서 시도해 불 수 있게 해야한다.
        단, 그 후보군을 선택할 수도, 하지 않을수도 있어야 한다.
            - 해당 후보군을 선택함으로써 다른 모든 경우가 망가질 수 있음.
            - 그럼 현재 몇번 후보군으로 조사하는지를 생각할 수 있어야 한다. 인자 추가
        또한, 그 조사 대상으로 부터 DFS 방식으로 전선을 연결해 나가게 할 것이다.
            - 그렇게 선택된 코어의 개수가 누적될 것이다. 인자 추가
        마지막으로, 조사하면서 전선의 길이도 누적되어 간다. 인자 추가
    '''
    '''4. 종료 조건 생각하기
        1. 모든 코어를 조사 완료한 경우        
        2. 지금까지 연결한 코어 + 남은 코어가 최대 코어보다 적은 경우 (가지치기)
        99. 코어 개수는 동일한데, 전선이 최대치보다 커진 경우는?
            - 섣부른 가지치기가 된다.
            - 우리의 목적은 더 많은 코어를 찾아 내는데 있음을 잊으면 안된다.         
    '''
    global core, result

    if acc_core + R - r < core:
        return
    if r == R:
        '''5. 값 갱신
            모든 코어가 연결된 경우...
            일단, 누적 코어와 결과 코어가 같으면? 
                누적 전선이 결과 전선보다 짧을때만 갱신가능
            누적 코어가 더 많으면? 그냥 갱신
        '''
        if acc_core == core:
            result = min(result, acc_line)
        elif acc_core > core:
            core = acc_core
            result = acc_line
        return
    ''' 6. 조사 진행 방식 생각
        r번째 코어를 조사하도록 한다.
            그 코어에서 4방향으로 조사를 보내야 한다.
        전선은 어차피 직선으로만 갈 수 있다.
            즉, 범위만 벗어날때까지 나갈수 있는지를 보면된다.
            단, 원본을 마구잡이로 바꾸면서 갈 수는 없다.
            백트래킹 생각하기도 어렵다. 차라리 전선이 이어질 수 있는 경우들만 생각하면 어떨까?
        이번 방향으로 나아가면서 그 좌표들을 저장해두고
            충분히 조사를 진행했는데, 벽을 벗어났다? 성공
            아니다? 실패 (nx, ny)가 범주 안에 있다면 이번 길을 못간다 가정.
        그렇게 끝까지 갔던 안갔던 누적값들 갱신해서 다음 프로세서 선택하도록 처리하고,
        아예 이번 코어를 선택하지 않은 경우도 생각하자. 해야하나>
    '''
    # 이번 코어
    x, y = candidate[r]
    for k in range(4):  # 4방향중 하나 선택해서 조사 출발
        nx, ny = x + dx[k], y + dy[k]
        temp_line = []  # 이번 회차 라인들
        # 갈수 있을떄까지 간다.
        while 0 <= nx < N and 0 <= ny < N and data[nx][ny] == 0:
            temp_line.append((nx, ny))  # 그 좌표들을 추가하며
            nx += dx[k] # 위치 동일 방향으로 갱신
            ny += dy[k]
        # 조사가 끝났는데 아직도 범위 안이다? 끝까지 못가나보네?
        if 0 <= nx < N and 0 <= ny < N: continue

        # 끝까지 갔다면? 저장해둔 전선라인을 원본에 전선으로 처리
        for lx, ly in temp_line:
            data[lx][ly] = -1

        # 그떄까지의 누적값으로 다음 조사
        search(r+1, acc_core+1, acc_line + len(temp_line))

        # 조사 갔다가 돌아왔니? 그럼 원복하고 다른 방향 조사하자
        for lx, ly in temp_line:
            data[lx][ly] = 0
    # 코어를 아예 선택 안하면 어떨까?
    search(r+1, acc_core, acc_line)

''' 0. 규칙 정리
    N*N 배열의 범위 밖은 전기가 흐른다?
    배열 내부 코어들은 범위 밖으로 나가는 최단 경로를 찾아야 한다.    (거리를 계산할까?)
    단, 그 경로가 서로 엉켜선 안된다. (이미 누군가 자리를 차지 했다면 불가능하다.)
    전선은 직선으로만 설치가 가능하다. 매우 중요하다...
'''
T = int(input())

for tc in range(1, T+1):
    N = int(input())
    data = [list(map(int, input().split())) for _ in range(N)]
    ''' 1. result 초깃값은 0? 
        최대한 많은 core를 구해야 한다. 이 때의 전선의 합.
        하지만, 전선의 길이는 동일 core 개수에 대해서는 최소이길 바람
            - 초기값을 무엇으로 설정해야 할지 모를땐, 바보같은 짓을 했을때를 가정한다.
            - 모든... 칸에 전부 전선을 넣었다고 생각해 보자.
        즉, 비교 대상은 core가 제일 많은지를 보기 위한 변수가 별도로 필요하고,
            동일 core일때에만 전선을 최소로 갱신한다.
        가장자리이면 이미 연결된 것이다. (가장자리의 값들은 그냥 core + 1 하면됨)
    '''
    result = N*N    # 모든 칸에 전선을 범벅시킨다.
    core = 0        # 일단 0으로 초기화
    candidate = [] # 모든 조사 대상 전선 좌표 찾기
    # 전수 조사
    for x in range(N):
        for y in range(N):
            ''' 2. 최댓값, 최솟값 갱신
                core가 있는 경우,
                core위치엔 전선을 둘 수 없음.
                가장 자리인 경우엔, 해당 core는 항상 사용 가능
                해당 자리는 다음 조사 후보군에 넣을 이유 없음. 
                전선과 동일 취급할 필요가 있음.
            '''
            if data[x][y]:
                result -= 1
                if x == 0 or x == N-1 or y == 0 or y == N - 1:
                    core += 1
                    data[x][y] = -1
                    continue
                # 가장자리를 제외한 경우 후보군에 삽입
                candidate.append((x, y))
    # print(core) # 가장자리인 경우 확인
    # print(candidate)
    R = len(candidate)  # 후보군의 개수 (종료 조건)
    # 일단 전수 조사
    search(0, core, 0)
    print(f'#{tc} {result}')