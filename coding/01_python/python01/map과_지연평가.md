[toc]

# map과 지연 평가: '이터레이터(Iterator)'의 이해 

> "왜 `map`은 `list()`로 감싸야 결과가 보이나요?"라는 질문의 핵심에는 '지연 평가(Lazy Evaluation)'라는 중요한 프로그래밍 개념이 있습니다.
>
> > range(), zip() 등도 마찬가지.



## 1\. `map` 객체는 '이터레이터(Iterator)'입니다

`map` 함수는 리스트와 같은 '이터러블(Iterable)' 객체를 받아, 그 결과로 '이터레이터(Iterator)'를 반환합니다.

  * **'이터러블 (Iterable)'**: `for`문으로 하나씩 요소를 꺼낼 수 있는 객체입니다. 리스트, 튜플, 문자열 등이 여기에 해당합니다. 말 그대로 '반복 가능한' 객체입니다.
  * **'이터레이터 (Iterator)'**: 값을 차례대로 꺼낼 수 있는 '흐름(stream)'을 가진 객체입니다. `next()` 함수를 호출하여 다음 값을 생성할 수 있으며, 한 번 소비하면 다시 사용할 수 없습니다.

`map`이 반환하는 이터레이터는 '어떻게 다음 값을 계산할지'에 대한 방법만 알고 있을 뿐, 아직 실제 값을 메모리에 만들어두지 않은 상태입니다. 이것이 바로 **'지연 평가 (Lazy Evaluation)'**의 핵심 원리입니다.

```python
numbers = [10, 20, 30] # '이터러블' 객체

# map은 이터러블을 받아 '이터레이터'를 반환합니다.
iterator_obj = map(lambda x: x * 2, numbers)

# 이터레이터 객체 자체를 출력합니다.
# 아직 계산이 실행되지 않았습니다.
print(iterator_obj)
```

**실행 결과:**

```
<map object at 0x1029c5c10>
```

이 결과는 "값을 계산할 준비가 된 이터레이터 객체가 메모리에 있다"는 의미입니다. 

실제 값 `[20, 40, 60]`은 아직 메모리에 존재하지 않습니다.



-----



## 2\. 이터레이터를 '소비(Consume)'하여 결과 보기

이터레이터가 가진 값을 실제로 보려면, 이터레이터를 `'소비'`해야 합니다. 

`소비`란 이터레이터에게 `next()`를 계속 요청하여 모든 값을 소진시키는 행위를 말합니다.



### 방법 1: `list()`로 이터레이터 소비하기

`list()`와 같은 생성자는 이터레이터를 인자로 받아, 그 안의 모든 요소를 꺼내(소비하여) 새로운 리스트를 만듭니다. 이 과정에서 지연되었던 모든 계산이 한 번에 수행됩니다.

```python
# list() 생성자가 이터레이터를 '소비'하여 모든 계산을 실행하고 리스트로 만듭니다.
result_list = list(iterator_obj)

print(result_list)
```

**실행 결과:**

```
[20, 40, 60]
```



### 방법 2: `for`문으로 이터레이터 소비하기

`for` 반복문 역시 내부적으로 이터레이터의 `next()`를 호출하여 값을 하나씩 꺼내 오는 대표적인 '소비자'입니다.

```python
# for 반복문이 이터레이터를 순회하며 값을 하나씩 소비합니다.
for item in iterator_obj:
    print(item)

# 중요: 위에서 list()로 이미 이터레이터를 소비했다면
# 이 for문은 아무것도 출력하지 않습니다. 이터레이터는 일회용이기 때문입니다.
```



---



## 3\. 왜 지연 평가를 사용할까? '메모리 효율성'

지연 평가의 가장 큰 장점은 `'메모리 효율성'`입니다.

만약 처리할 데이터가 10억 개라면, 결과를 미리 전부 계산해서 리스트로 만드는 것은 엄청난 메모리를 차지할 것입니다. 하지만 이터레이터는 값을 요청받을 때마다 단 하나만 계산해서 돌려주므로, 아무리 큰 데이터라도 최소한의 메모리만 사용하여 처리할 수 있습니다.



## 핵심 요약

  * `map(...)`: '이터레이터(Iterator)'를 반환합니다. 
    이 이터레이터는 '지연 평가(Lazy Evaluation)' 원리에 따라 동작합니다.
  * `list(map(...))`: 이터레이터를 '소비'하여 모든 요소를 계산하고, 그 결과를 리스트라는 새로운 자료구조로 '구체화'하는 과정입니다.
  * 기술적 흐름: `map(함수, 이터러블)` → `이터레이터` 생성 → `list()`로 `소비` → 지연되었던 계산 실행 → 결과 `리스트` 반환.