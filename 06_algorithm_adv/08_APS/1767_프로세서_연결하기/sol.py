import sys
sys.stdin = open('input.txt')

# 상하좌우
dx
dy

def f(r, acc_core, acc_line):
    '''1. 조사 규칙 정리
        모든 후보군에 대해서 조사를 한다.
            이때... 코어의 순서 중요한가?
        모든 후보군에 대해서 다 조사를 출발 시켰는가?
            - 아 그럼, 종료조건은 내가 지금 몇번째 후보군을 조사하고 있는지
            음..... 이번 후보군을 가지고 전선 이었던것들 지울수도 있어야 할 듯?
                원복 시킬 방법 생각해야 할듯? -> 백트래킹 방식으로
                    재귀형식인가? N이 작고, 조건이 간단해서 limit 안걸릴듯?
            그 조사방식... 내가 점점 앞으로 나아가는 방식? 재귀필요한가?
                아니? 직선으로 범위 벗어날때까지, 혹은 더 못갈땎라지만 하면되는데
                그냥 while 하면 될듯?
                그걸 상하좌우 4번 해야할듯?
        그 후보군을 선택 안한다고 생각 해 봐야함.\
    '''
    '''99. 가지치기
        유망성 없는 경우는 무엇인가?
        1. 최대한 많은 코어를 구할 것이다.
            -> 이때 유망성 없는 상황은 뭘까? 
            지금까지 선택한 코어 + 아직 선택안헀지만 선택할수도 있는 코어
            의 수가
            이미 예전에 구했던 최대 코어보다 작으면?
        2. 코어가 최대한 많아야하고, 전선은 최대한 짧아야 한다...?
            전선이 짧아야하니까... 누적된 코어가 최대 코어랑 같은데
            전선이 이미 더 길어...
            유망성있나?  
            섣부른 가지치기가 될 수도 있다.
            왜?
            사실... 이 문제의 가장 큰 문제는 더 많은 코어
    '''
    if 지금까지 선택한 코어 + 아직 선택안헀지만 선택할수도 있는 코어 < 최대코어:
        유망성 없음

    if 현재 조사중인 후보군 idx == R (모든 후보군의 개수만큼)
        '''99. 값 갱신
            누적코어 개수, 현재 찾은 최대 코어 개수 비교
            누적 코어 == 최대 코어
                전선이 더 짧을때 전선만 갱신
            누적 코어 > 최대 코어
                최대 코어 개수 갱신
                전선도 갱신
        '''
    # 전수조사
    '''2. 이번 후보군에 대한 조사 방식
        이번 후보군이 누군데? 재귀형식으로 할거였으니까? 인자 추가
        이번 회차에서 전선 연결가능한지 찾앗으면
            그 전선개수, 이번 후보군 코어 선택했으니까, 누적 인자 추가
    
    '''
    x, y -> candidate[r]
    for k > 4:
        nx + k
        ny + k
        temp_line >>[]
        # 갈수 있을때까지 간다
        while 0 <= nx, ny <= N and data x, y == 0:
            temp_line + (nx, ny)
            # 전선을 이어 나갈까? 원본을 바꿀까?
            # 원본을 지금 죽 바꿔나가면 나중에... 백트래킹해서 돌아왔을때
            # 어디서부터 어디까지 다시 0으로 돌려야할까?
            # 전선을 어느 좌표에 전선처리 했는지 모아두면안됨?
            nx + k, ny + k >> 한방향으로 계속 이동
        # 위에서 한방향으로 쭉 갔는데...
        if 0 <= nx, ny < N:  >> 여전히 셀 안이다? 가장자리 도달 못했나보네?
            continue        >> 이 방향으로는 전선을 연결 할 수 없나보네.

        # 끝까지 갔어? 그럼 모았던 전선들 모두 원본에 전선처리해서
        # 다음 조사에 영향 미치도록 해두기
        for line pos > temp_line:
            data line pos -> -1

        # 다음 후보군 선택하러 가기
        f(r++, acc_core++, acc_line+len(temp_line))

        # 조사갔다가 돌아왔다? 다음 선택지에 영향 안미치도록 원복
        for line pos > temp_line:
            data
            line
            pos -> 0
    # 이번 후보군 아예 선택안하가ㅣ
    f(r++ ... )


'''0. 규칙 정리
    첫번째. 셀 범위밖으로 직선으로 이어야 한다.
        최대한 많은 코어가 (모든 코어가 가능한지 조사)
    두번째. 가장자리에 있는 코어는 이미 연결되어 있다. (나의 탐색 조사 대상아니다.)
        이미 연결되어 있으니, 조사 대상은 아니지만
        결과에는 영향을 미친다. 즉, 시작할때 코어가 이미 가장자리 개수만큼 초기화
    세번째. 전선은 교차가 안된다.
    네번재, 최대한 많은 코어, 최대한 짧은 전선
        최대한 짧은 전선? 나랑 가장 가까운 벽 찾기?       
        직접 보내야 한다. (완전 탐색해야 할 듯)
'''

T
for tc -> 1, T
    N
    data -> N*N >> 0벽, 1코어
    # 최종 출력 대상 초기화
    # 가장 바보같은 선택지를 생각해보자.
    r -> 전선의 길이 최대한 짧아야 한다.: N*N
    c -> 코어의 개수 : 0
    '''1. 조사를 위한 준비
        조사 대상 (후보군): 코어
        단, 가장자리가 아닌 코어들
            반대로, 가장자리의 코어는? 초기값에 넣어두자.
    '''
    candidate >> []
    for x > N
        for y > N
            data x, y:  < 코어가 있음
                r-- < 전선 연결 못함
                if 가장자리인 경우
                    c++     <- 이미 확정된 코어임
                    data x, y <- -1로 변경 (조사 대상 아니고, 전선 연결도 못함)
            코어가 있고, 가장자리도 아니면 후보군에 추가
    이제 내가 가진 모든 후보군에대한 조사
    몇개? len(후보군)
    # 일단 전수조사
    f(0, c, 0) <- 함수에 인자 뭐 넣어야 할지 모르겠네..
                









