# 서로소 집합
## 서로소 집합(Disjoint-set)
서로소 또는 상호배타 집합들은 서로 중복 포함된 원소가 없는 집합들임

-> 즉, 교집합이 없다

- **두 집합 간에 공통 원소가 하나도 없을 때**, 이 두 집합을 서로소 집합이라고 함

- 집합에 속한 하나의 특정 멤버를 통해 각 집합들을 구분함
  - 이것을 대표자(representative)라고 함

- 상호배타 집합을 표현하는 방법
  - 연결 리스트(클래스로 구현)
  - 트리(리스트로 구현)

- 상호배타 집합 연산
  - `Make-Set(x)` -> 각 집합들을 본인이 대표자인 집합으로 만듦
  - `Find-Set(x)` -> 대표자 찾음
  - `Union(x, y)` -> 공통원소 없는 집합들 합치기
    - 합친다는 것은 x가 y의 대표자에게 붙거나, y가 x의 대표자에게 붙는 것

- 서로소 집합 예시

  ![alt text](image.png)
  - Find-Set(y) 실행시켰을 때 y가 속한 집합의 대표자 x를 출력할 수 있게됨
  - 대표자 x와 대표자 a를 Unoin하면 두 집합이 하나의 큰 집합으로 합쳐짐

## 서로소 집합 표현
### 서로소 집합 표현 - 트리
- 같은 집합의 원소들을 하나의 트리로 표현
  - 이진 트리 아님을 주의하자!
- 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 됨

  ![alt text](image-1.png)
  - a는 트리의 루트 노드를 가지고 있음(a 본인이 대표자)
    - d와 a를 합집합할 때 a를 대표자로 둔다면, a의 자식으로 d가 들어오는 형태
    - b를 부모 노드로 가지는 자식 f가 있거나, 자기 혼자만 존재하는 형태로 있는 트리 c가 있을 수 있음

  - 이진트리가 아니기 때문에 리스트로 트리 구현했을 때 인덱스 약속을 지킬 수 없음
    - `부모 인덱스 = 자식 인덱스//2` -> 사용XX
  - 그렇다면 리스트에 `(부모 인덱스, 값)`인 튜플 형태로 나타내자
    - 두번째 그림을 표현하면
      ```
      index  0     1     2
      list   X   (1,b) (1,f)
      ```
      - 2번 인덱스에 있는 노드의 값은 f이고, f의 부모 노드는 1번 인덱스에 있다
      - 1번 인덱스에 있는 노드의 값은 b이고, b의 부모 노드는 자기 자신이다
  - 만약 a와 b를 union 한다면 
    - 루트 노드를 a로 유지한다고 정했을 때 아래와 같이 트리 형태를 유지한 상태로 관계만 집합 형태로 만들 수 있음

      ![alt text](image-6.png)
      ```
      index  0     1     2     3     4     5     
      list   X   (1,a) (1,d) (1,e) (1,b) (4,f)
      ```

- 서로소 집합 트리 표현 순서
  1. `Make-Set(a)` ~ `Make-Set(f)`

      ![alt text](image-2.png)
    - Make-Set을 이용해서 각자가 자신을 바라보도록 만들기
    - 즉, 부모 정보에 자기 자신 인덱스가 들어가도록 함
  2. `Union(c,d)` , `Union(e,f)`

      ![alt text](image-3.png)
    - c와 d를 Union하면 d의 부모 정보에 c의 인덱스를 넣음

  3. `Union(d,f)`

      ![alt text](image-4.png)
    - d와 f Unoin하려는데 d,f가 각 집합의 대표자가 아니므로 대표자를 찾음
    - d의 대표자 c와 f의 대표자 e가 합쳐져 c가 합친 집합의 대표자가 되도록 트리 구성

- `Fine-Set(d)`, `Find-Set(e)` -> return c

- 서로소 집합을 표현한 트리의 배열을 이용해 저장된 모습

  ![alt text](image-5.png)

## 서로소 집합 연산
- `make_set(x)`
  - 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산
    ```python
    def make_set(n):
        '''
            n: 집합을 만들 원소의 개수
        '''
        # 우선 자기 자신을 대표자(부모)로 하는 배열 반환
        return [i for i in range(n+1)]
    ```

- `union(x,y)`
  - x와 y를 포함하는 두 집합을 통합하는 연산
    ```python
    def union(x, y):
        '''
            x, y: 합쳐질 두 집합의 원소
            유니온 과정에 삽입 대상 원소는 그 원소의 집합의 대표자가 아닐 수 있음!!
        '''
        # 두 집합을 합친다는 것은
        # 두 원소가 속한 집합의 대표자가 서로 다르다면?
            # 원소 y가 속한 집합의 대표자를 x로 바꾸거나
            # 원소 x가 속한 집합의 대표자를 y로 바꾸거나
            # parent[y 집합의 대표자] = x 집합의 대표자
            # 그럼 두 원소가 속한 집합의 대표자를 먼저 알아야 함
                # find_set(x)
        root_x = find_set(x)
        root_y = find_set(y)
        if root_x != root_y:
            parent[root_y] = root_x
        
        # 두 원소의 대표자가 같으면
            # 이미 두 원소는 같은 집합 소속인 것임
    ```
    - union에 넣은 원소 x, y를 합치는게 아니라 x의 대표자와 y의 대표자를 합쳐야함을 유의하자

- `find_set(x)`
  - x를 포함하는 집합을 찾는 연산
    ```python
    def find_set(x):
        '''
            원소 x가 속한 집합의 대표자가 누구인지 반환한다
        '''
        if x == parent[x]:    # 원소 x가 속한 집합의 대표자가 자기 자신이면
            return parent[x]    # 자기 자신 반환
        
        # 자기 자신이 아니라면
        # x의 대표자로 지정된 원소의 대표자가 누구인지 찾는다
        return find_set(parent[x]) 
    ```

※ 합쳐놓은 집합을 가지고 무엇을 할까?

-> 특정 노드에서 다른 특정 노드까지의 거리 측정

-> 노드 들이 어떤 경로에 포함되어 있는지 확인

-> 내 집합과 타 집합의 특정 원소들이 공통 조상을 가지고 있는지 확인

-> 위 경우들에 서로소 집합 사용할 예정

### 서로소 집합 연산의 문제점
![alt text](image-7.png)
- 1~5를 거쳐 서로소 집합을 만들었음
  - b가 e 원소와 같은 서브트리 내에 존재하고 있는지 확인하고 싶음 -> `Find-Set(b)`, `Find-Set(e)`
    - b가 속한 집합의 대표자는 f
    - e 또한 대표자는 f
    - 그럼 같은 서브트리에 존재한다고 판단

- 편향 트리로 집합이 만들어 졌을 때 말단(ex. a)에서 대표자(ex. f)를 찾으려면 N번 연산이 필요함
  - 왜? 나는 부모 인덱스 정보를 가지고 있기 때문에 N번 연산을 통해 부모를 타고타고 루트까지 가야함

- Union으로 대표자들끼리 합쳤을 때 탐색 연산 길어지는 여러 경우들이 생김
  - 탐색 시간 줄일 필요성 있음

## 서로소 집합 최적화
- `Path compression`
  - Find-Set을 행하는 과정에서 만나는 **모든 노드들이 직접 root를 가리키도록** 포인터를 바꾸어줌
    - 위에서 서로소 집합 코드 작성한게 평탄화 없이 부모 노드를 가리키도록 작성한 것
    - 평탄화를 진행하면 a가 b를 가리키지 않고 a와 b 모두 f를 가리킴
    - b가 a의 부모였다는 것은 사라지지만, a와 b의 **원소 간 관계**는 유지됨(같은 집합에 속해있다는 것)
  - 해당 집합이 하나의 대표자를 기반으로 한 집합인지만 나타내고자 한다면 경로 최적화(평탄화 작업) 진행 가능

- `Rank를 이용한 Union`
  - 각 노드는 자신을 루트로 하는 subtree의 높이를 rank로 저장함
  - 두 집합을 합칠 때 rank가 낮은 집합을 rank가 높은 집합에 붙이기

※ Path compression과 Rank를 이용한 Union 모두 각 노드의 부모 노드가 누구인지 중요한 상황에서는 사용하면XX

### Path Compression 최적화
Path Compression을 적용한 Find-Set 연산은 **특정 노드에서 루트까지의 경로를 찾아가면서 부모 노드를 갱신**함

![alt text](image-8.png)
- h를 기존에 있던 a~g 서브트리에 합칠 때 그냥 합치는 것이 아니라
  - h가 부모라고 바라볼 e가 사실은 a를 루트로 하는 집합의 요소였음
  - 그렇다면 h는 바로 a에게 붙이고, e도 a에 붙도록 하겠다
  - 즉, 평탄화 과정을 union할 때마다 진행

- Find-set(x) 최적화(x를 포함하는 집합을 찾는 오퍼레이션)
  ```python
  # 02_dsu_path_compression.py

  def make_set(n):
    return [i for i in range(n+1)]

  def find_set_pc(x):
      """경로 압축이 적용된 find_set"""
      # 원소 x가 속한 집합의 대표자가 자기 자신이면
      if x == parent[x]:
          return parent[x]
      # 아니면?
      # 원소 x의 대표자를, 그 대표자의 대표자로 변경
      parent[x] = find_set_pc(parent[x])
      return parent[x]

  def union(x, y):
      """두 집합을 합치기"""
      root_x = find_set_pc(x)
      root_y = find_set_pc(y)
      if root_x != root_y:
          parent[root_y] = root_x
  ```
  - 평탄화는 필요할 때만 하자
    - 편향트리인 경우엔 한번에 평탄화가 되지만, 서브트리가 여러개이면 평탄화 여러번 해야함
    - 평탄화가 굳이 필요하지 않은 상황에서 평탄화 여러번 해놓을 필요XX

  - 최적화 전 vs 후 차이

    ![alt text](image-9.png)
  
### Rank 최적화
랭크를 이용한 Union

![alt text](image-10.png)
- 왜 랭크 이용해서 합쳐야하냐?
  - 만약 

  ![alt text](image-11.png)


  