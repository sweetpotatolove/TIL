import sys
sys.stdin = open('input.txt')


from collections import deque

def gravity(copy_data):
    '''
        중력을 적용시킨다... 음...  위에서부터 내려가게 하려고한다.
        0 0 0 0 0
        0 2 0 1 1    <- (1,1)에 있는 애는 1 찾아서 아래로 델타 탐색해서 내리면...될거 같은데...
        0 0 0 1 1    <- (1, 3), (1, 4)에 있는 애는 그 밑에 또 1이라서.... 답이없다...
        0 4 0 0 0
        0 9 1 1 1
        이걸 내가 왜 일일히 한칸씩 내림? 0을 없애면 되는거 아님?
        0을 무시하면 되는거 아님?
        밑에서부터 세어 올라가서 (어디에 저장해두고)      0
        숫자가 어느 순으로 있는지 세면서 0으로 없애고...  0
        끝까지 다 셌으면 도로 채우면 되는거아님?          0
        column 1에 대해서만 생각해보면                    2
        뒤에서부터 새면서 0으로 바꾸면 다 0이 될거고      4
        [9, 4, 2] 이걸 다시 밑에서 부터 채워 넣으면       9
    '''
    # 모든 열에 대해서
    for c in range(W):
        temp_q = deque()
        for r in range(H-1, -1, -1):
            if copy_data[r][c] > 0: # 빈 공간이 아니면
                temp_q.append(copy_data[r][c])
                copy_data[r][c] = 0
        # 다시 아래서부터 채워 넣기
        row_idx = H-1
        while temp_q:   # 찾아낸 벽돌들 다 떨어질때까지
            copy_data[row_idx][c] = temp_q.popleft()
            row_idx -= 1




# 상하좌우
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def bomb(r, c, copy_data):
    '''
        :param r, c: 폭파 작업을 시작할 좌표
        상하 좌우를 copy_data[r][c]에 작성된 숫자 범위 - 1 만큼 폭발!
        DFS? BFS? 뭐가 더 생각하기 쉽나?
        같은 범위를 동시에 후보군에 넣어가는게 범위 계산하고 멈추기 쉬워서 BFS로 할거임
    '''
    # 좌표값과 함께, 얼마나 더 터트리러 갈 수 있는지도 알아야지...
    # 좌표 값, 터트릴 범위
    q = deque([(r, c, copy_data[r][c])])
    copy_data[r][c] = 0 # 터트린다.

    while q:
        x, y, count = q.popleft()
        for k in range(4):  # 4방향 조사
            '''
                다음 위치는 현재 위치 + [(-1, 0), (1, 0) ... ]
                등을 k번째에 있는 값을 더해서 만든다.
                지금 만들려는 범위는 그 k를 Di 번 만큼 더하면 된다. 
            '''
            for p in range(1, count):
                '''
                    x, y가 0, 0 일때 (1, 0), (2, 0), (3, 0) ... 은? 1 * p 식으로 증가한다.
                '''
                nx = x + dx[k] * p
                ny = y + dy[k] * p

                # 그럼 탐색 범위를 어떻게 잡을 것이냐?
                '''
                    1. 게임판의 범위를 벗어나지 않는다
                    2. 0 이면... 못가나? 아님 갈 수 있음 여전히...
                    3. 숫자가 크면? 작으면? 상관없음..
                    그럼... 조사 불가능한 지역이라는 범위만 벗어나지 않으면 될 듯?
                '''
                # 부정 (범위를 벗어나지 않는다면?) -> 범위를 벗어나면...
                if not (0 <= nx < H and 0 <= ny < W): continue

                # 이제 지나가는 그 범위안의 벽돌이 어떠한 수를 가지고 있다면
                if copy_data[nx][ny] > 0: # 다음 후보군 (범위가 1이여도 후보군임)
                    q.append((nx, ny, copy_data[nx][ny]))
                    copy_data[nx][ny] = 0   # 뭐.. 그건 그거고 벽돌 없애기는 없애고...



'''
먼저 시도해 볼 것.
1. 완전 탐색 해보기. - 즉, 구슬 그냥 떨어뜨려보기
2. 구슬을 N 번 떨어뜨리는건 나중에 생각하고 그냥 떨어뜨리기
'''
def search(cnt, data):
    '''
        :param cnt: 몇번 구슬을 떨어뜨렸는지 카운트
        :param data: 벽돌 정보 (구슬을 떨어뜨릴때마다, 원본 데이터가 바뀔텐데...)
                        완전 탐색으로 구슬을 (0,0) (0,1) (0,2) (0,3) ... 에 떨어뜨리면 결과가 달라짐!
                        그래서, 첫번째 시도와 2번째 시도는 원본으로 똑같은 조건하에 해야함!
                        원본 데이터의 복제본이 필요함
        :return:
    '''
    global result
    # result가 이미 0이면 더 조사할 필요 없는거 아님?
    if result == 0:
        return

    # 왜 5번째 tc는 cnt 가 N이 되는게 없을까?
    # 언젠간 끝나야 한다.
    if cnt == N:    # 구슬을 다 쏘면 끝난다.
        # 현재 남아 있는 벽돌을 세어야 한다.
        bricks = 0
        for r in range(H):
            for c in range(W):
                if data[r][c] > 0:
                    bricks += 1
        result = min(result, bricks)
        return
    # 일단! 구슬을 떨어뜨려. 근데 어디에? 몰라! 0부터 W-1 까지 다 떨궈보자.
    for c in range(W):
        '''
            단, 이번 회차에서 쓸 복제본 데이터를 가지고 부숴봐야 한다.
            c가 0일때 (0,0) 위치에 구슬 쐈을때, 벽돌 알마나 부서지는지 보고....
            c가 1일때 (0,1) 위치에 구슬 쐈을때, 벽돌 얼마나 부서지는지 보려면... 원본 바꾸면 안됨!
        '''
        copy_data = [row[:] for row in data]    # 2차원 배열 깊은 복사
        # c=0 (0, 0)에서 구슬을 떨어뜨린다...? 아래로 점점 내려간다. -> ladder 1 에서 해봤다.
        r = 0       # 가장 밑바닥 까지 빈 공간이면 내려간다.
        while r < H and copy_data[r][c] == 0:
            r += 1
        # 멈춘 지점? 밑바닥이거나 벽돌이 있는 곳이다.
        # 벽돌이 있다면 (즉, 밑바닥이 아니라면!)
        if r < H:
            # 벽돌 폭파 작업 진행
            bomb(r, c, copy_data)
            # 중력...... 해결해야지...
            '''
                bomb 함수에 넘겼던 저 copy_data.... 내가 별도의 return 안해도 되나?
                ㅇㅇ 안해도 됨. 왜? 우리가 bomb 함수 안에서 한건
                2차원 배열의 index로 직접 지정해서 처리 했기 때문에
                LEGB 룰과 무관하게 잘 수정됨!
            '''
            gravity(copy_data)
            # 다음 구슬 쏴야함....
            search(cnt + 1, copy_data)
        # 바닥에 도달하는 경우도... 그냥 넘겨야 겠구나...?
        else:
            search(cnt +1, copy_data)



T = int(input())
for tc in range(1, T+1):
    # N: 구슬의 개수, W: 너비, H: 높이
    N, W, H = map(int, input().split())
    data = [list(map(int, input().split())) for _ in range(H)]
    # 최대한 적은 벽돌의 수: 최솟값 찾기
    result = W*H  # 충분히 큰 값으로 초기화

    '''
        1. 구슬을 떨어뜨려서 벽돌을 만난다. ?
        2. 그렇게 벽돌을 만나면, 벽돌에 적힌 숫자 만큼... 상하좌우로 폭탄이 터진다.
            2-1. 2에서 터지고 있는 과정에서 만나는 벽돌에 적힌 숫자만큼도 또 터진다.
            (모든 상하좌우로 터져야 하는 벽돌들의 후보군을 모을 수 있어야 할것이고,
            그 후보군들이 아예 없어질때까지 터지게 해야한다.)
            # 그걸... 깊이우선으로 할지 너비 우선으로 할진 모르곘다!
        3. 2에서 터트릴 수 있는 모든 벽돌을 없애고 나면... 중...력을...적용해야...한단다....
        4. 1~3을 N번 할 수 있다.
        5. 그때 가장 벽돌이 적은 경우를 구해야 한다.
    '''
    search(0, data)

    print(f'#{tc} {result}')